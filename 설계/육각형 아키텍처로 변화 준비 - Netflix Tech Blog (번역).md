> 본 포스트는 Netflix 기술 블로그에서 발췌한 [Ready for changes with Hexagonal Architecture](https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749) 게시글을 번역한 것입니다.

Netflix Originals의 제작이 매년 증가함에 따라 컨텐츠 제작 과정에서 효율성을 증가시키는 앱을 구축해야 할 필요성도 커지고 있습니다. 우리의 `Winder Studio Engineering` 팀은 컨텐츠 스크립트 획득, 거래 협상 및 공급업체 관리, 제작 절차 간소화 등 컨텐츠의 각본부터 제생에 이르기까지 제작을 돕는 수많은 앱을 구축했습니다.

# 처음부터 엄청난 통합
약 1년 전, Studio Workflow 팀은 비즈니스의 여러 도메인을 넘나드는 새로운 앱을 개발하기 시작했습니다. 우리는 흥미있는 과제를 가지고 있었습니다. 처음부터 어플리케이션의 핵심(core)을 만들어야 했고, 각기 다른 시스템에 있는 데이터도 필요했습니다.

영화, 제작일, 직원, 촬영지 등 우리가 필요한 데이터는 여러 프로토콜들로 흩어져 있었습니다. (gRPC, JSON API, GraphQL 등) 흩어져 있는 기존 데이터들은 어플리케이션의 동작과 비즈니스 로직에 매우 중요한 영향을 끼치기 때문에 우리는 꼭 시작부터 `통합(integrate)`할 필요가 있었습니다.

# 스왑 가능한 데이터
생산량 향상을 위한 초기 어플리케이션 중 하나는 모노리스(monolith)로 구축되었습니다. docker와 같은 container space에 대한 지식이 없는 동안 모놀리스는 빠른 발전과 빠른 변화를 가능하게 했습니다. 한때는 30명 이상의 개발자가 하나의 모놀리스 어플리케이션을 개발했고 300개가 넘는 데이터베이스 테이블이 있었습니다.

시간이 지남에 따라 어플리케이션의 서비스의 `영역`이 넓어지기 보다 `전문성`이 깊어지는 것으로 발전했고, 그 결과 모놀리스를 특정 서비스와 도메인 단위로 분해하기로 결정했습니다. 이러한 결정은 컴퓨팅 성능 문제에 의해 고려된 것이 아닌 도메인별로 나눈 모든 서비스를 배정한 담당 팀이 서비스를 `독릭적`으로 `전문성` 있게 개발할 수 있기 때문입니다.

새로운 어플리케이션에 필요한 대용량의 데이터는 여전히 모놀리스를 통해 제공받았지만, 모놀리스가 언제가 전부 분해될 것을 예상했습니다. 그 시기는 특정지을 수 없었지만 `대비`는 필요했습니다. 

이렇게 하여 여전히 모놀리스의 데이터베이스 중 일부를 활용해야 했지만, 마이크로 서비스가 시작되는 즉시 기존 데이터베이스를 교체할 수 있도록 준비할 수 있었습니다. 

# 육각형 설계의 영향력
비즈니스 로직에 영향을 끼치지 않고 데이터베이스를 교체 할 수 있는 기능을 지원해야 했습니다. 그러기 위해서는 먼저 데이터베이스를 분리해야 했습니다. 그래서 우리는 육각형 설계의 원리를 기반으로 어플리케이션을 구축하기로 했습니다.

육각형 설계의 아이디어는 입출력(API)을 우리 디자인 패턴의 가장자리에 배치하는 것입니다. 비즈니스 로직은 REST API 또는 GraphQL API 중 어느 것을 노출하느냐에 따라 달라져서는 안 되며, 데이터베이스, gRPC, REST를 통해 노출되는 마이크로 서비스 API, 단순 CSV 파일 등 어디에서 데이터를 얻느냐에 따라 달라져서는 안 됩니다.

이 패턴은 어플리케이션의 핵심 로직을 외부 관심사로부터 분리할 수 있게 해줍니다. 코어 로직을 분리하면 [코드베이스](https://ko.wikipedia.org/wiki/%EC%BD%94%EB%93%9C%EB%B2%A0%EC%9D%B4%EC%8A%A4)에 큰 영향을 미치거나 **중요한 코드를 수정하지 않고 데이터베이스 세부 정보를 쉽게 변경할 수 있습니다.**

또한 명확한 경계가 있는 어플리케이션을 사용하는 데 있어 얻는 주요 이점 중 하나는 **테스트**입니다. 대부분의 테스트를 쉽게 변경할 수 있는 프로토콜에 의존하지 않고 비즈니스 로직을 검증할 수 있습니다. 

# 핵심 개념 정의
육각형 설계를 활용하여 비즈니스 로직을 정의하는 세 가지 주요 개념은 **Entity, Repository 및 Interactors**입니다.
- **Entity**는 도메인 객체(예시로 동영상 촬영 위치)이며, Ruby on Rails의 Active Record 또는 Java Persistence API(JPA)와 달리 엔티티들은 자신들이 어디에 저장되는지 전혀 모릅니다.
- **Repository**는 엔티티를 만들고 변경하는 인터페이스입니다. 데이터베이스와 통신할 때 사용되는 메소드들을 보관하고 단일 엔티티 또는 엔티티 목록을 반환합니다. (예: UserRepository)
- **Interactors**는 도메인 행동을 조정하고 수행하는 클래스입니다. 이는 서비스 오브젝트와 유스케이스 오브젝트와 비슷합니다. 도메인 작업(예: 프로덕션 온보드)에 특화된 복잡한 비즈니스 규칙과 validation 로직을 구현합니다.

이러한 세 가지 주요 유형의 개체를 사용하면 데이터가 보관되는 위치, 비즈니스 로직의 트리거가 되는 방법에 대한 지식이나 관심 없이 비즈니스 로직을 정의할 수 있습니다. 비즈니스 논리의 바깥에는 다음과 같은 데이터 소스와 전송 계층이 있습니다.

![Hexagonal Architecture](./Hexagonal%20Architecture.png)
Hexagonal Architecture의 의존성 그래프는 안쪽으로 이동합니다.

기존의 전통적인 계층 구조는 모든 의존성이 한 방향을 가리킵니다. 각각의 계층은 아래의 계층에 따라 쉽게 변하게 됩니다. 전송 계층(transport layer)은 인터랙터(intteractors)에 의존할 것이고, 인터랙터는 지속성 계층(persistence layer)에 의존할 것입니다.

반면에 Hexagonal Architecture에서 모든 의존성은 내부를 가리킵니다. 핵심 비즈니스로직은 전송 계층이나 데이터베이스에 대해 관심사가 분리되어 있습니다. 여전히 전송 계층은 인터랙터를 사용하는 방법을 알고 있습니다. 그리고 데이터베이스는 레파지토리 인터페이스를 준수하는 방법을 알고 있습니다.

이를 통해 다른 Studio 시스템의 불가피한 변경에 대비하고 있습니다. 그리고 필요할 때마다 데이터베이스 스왑 작업을 쉽게 수행할 수 있습니다.

# 데이터베이스 교체
데이터베이스를 교체해야 할 필요성이 예상보다 일찍 나타났습니다. 갑자기 모놀리스로 읽기 제약 조건에 부딪혔고 한 엔터티에 대한 특정 읽기를 GraphQL 집합 계층(aggregation layer)에 노출된 새로운 마이크로서비스로 전환해야 했습니다. 마이크로 서비스와 모놀리스 모두 동기화 상태를 유지하고 동일한 데이터를 가지고 있어 한 서비스 또는 다른 서비스에서 읽어도 동일한 결과가 생성되었습니다.
```
src
│   app.js          # App entry point
└───api             # Express route controllers for all the endpoints of the app
└───config          # Environment variables and configuration related stuff
└───jobs            # Jobs definitions for agenda.js
└───loaders         # Split the startup process into modules
└───models          # Database models
└───services        # All the business logic is here
└───subscribers     # Event handlers for async task
└───types           # Type declaration files (d.ts) for Typescript
```
