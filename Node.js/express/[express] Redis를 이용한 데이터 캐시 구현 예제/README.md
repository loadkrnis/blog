## 들어가며

웹 어플리케이션에서 데이터를 캐시하는 것은 매우 중요하며 고성능을 얻을 수 있습니다. 물론 데이터를 관계형 데이터베이스에 저장 후 직접 쿼리하여 사용자에게 제공할 수 있지만 매 요청마다 쿼리를 해야하거나 메인페이지에 사용되는 타 API에 비해 상대적으로 많이 호출되는 데이터들은 캐시하는 것이 유리할 수 있겠습니다. 먼저 간단히 Redis에 대해 알아보고 express로 구현 예제를 작성하겠습니다.

## Redis란?

**REDIS(REmote Dictionary Server)**는 메모리 기반의 “키-값” 구조 데이터 관리 시스템이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장하는 비 관계형 데이터베이스입니다.

-   대표적으로 5가지의 데이터 형식으로 사용 가능합니다.

1.  String
2.  Lists
3.  Sets
4.  Sorted sets
5.  Hashs

Redis는 빠른 오픈 소스 인 메모리 **키-값** 데이터 구조 스토어이며, 다양한 인 메모리 데이터 구조 집합을 제공하므로 사용자 정의 애플리케이션을 손쉽게 생성할 수 있습니다. 

#### 장점

-   리스트, 배열과 같은 데이터를 처리하는데 유용
-   value 값으로 다양한 데이터 형식을 지원하기 때문
-   리스트형 데이터 입력과 삭제가 MySql에 비해 10배정도 **빠르다.**
-   여러 프로세스에서 동시에 같은 key에 대한 갱신을 요청하는 경우, 데이터 부정합 방지 Atomic 처리 함수를 제공한다(원자성).
-   메모리를 활용하면서 영속적인 데이터 보존(Persistence)스냅샷 기능을 제공해 메모리 내용을 \*.rdb 파일로 저장하여 해당 시점으로 복구할 수 있다.
-   AOF : Redis의 모든 Wirte/Update 연산을 log 파일에 기록 후 서버 재시작 시 순차적으로 재실행, 데이터 복구
-   명령어로 명시적 삭제, expires를 설정하지 않으면 데이터가 삭제되지 않는다.
-   1개의 싱글 쓰레드로 수행되기 때문에, 서버 하나에 여러개의 Redis Server를 띄울 수 있다.(Master-Slave 구조)
-   master-slave 간의 복제는 **non-blocking**

#### 단점

-   **메모리 파편화**가 발생하기 쉽습니다.
    -   메모리를 **2배**로 사용합니다.
    -   Redis는 **싱글 쓰레드**이기 때문에 스냅샷을 만들 때 자식 프로세스를 하나 만들낸 후  
        새로 변경된 메모리 페이지를 복사해서 사용합니다.
    -   Redis는 **copy-on-write 방식**을 사용합니다.
    -   보통 Redis를 사용할 때는 데이터 변경이 잦기 때문에 실제 메모리 크기만큼 자식 프로세스가 복사합니다.  
        그래서 실제로 필요한 메모리 양보다 **더 많은 메모리**를 사용하게 됩니다.

**In-memory(휘발성)** 방식이기 때문에 장애 발생시 데이터 유실이 발생할 가능성이 있습니다.

> 따라서 중요한 데이터를 Redis에 저장하는 것 보다 관계형 데이터베이스에 있는 데이터를 **빠른 응답을 위해 캐시**하는 용도가 적합합니다. 그리고 데이터 보존을 위해 스냅샷과 AOF 기능을 통한 복구 방식을 주의해서 작성해야 데이터 유실에 대비할 수 있습니다.

## 예제

오늘 만들어볼 예제는 [university-domains-list](https://github.com/Hipo/university-domains-list) 를 이용하겠습니다. 이 공개 API는 터키에 있는 대학교를 제공해줍니다.

> http://universities.hipolabs.com/search?name=university&country=turkey

위 주소로 터키의 대학교 리스트를 JSON으로 내어주는 API 엔드포인트입니다. 우리가 만들어볼 서버는 NodeJS 웹 어플리케이션에 기본적인 데이터 캐시로직을 구현해 보겠습니다.

우리의 서버는 간단한 로직을 가집니다. 클라이언트로 부터 요청을 받으면 먼저 위 공개 API 주소로 요청을 보내 결과를 받고 그대로 클라이언트에게 전달하는 로직을 구현할 예정입니다.

**하지만 매 요청마다 공개 API에 요청을 보내고 받고, 받은 결과를 클라이언트에게 전달하는 것은 빠른 응답을 한다고 보기는 힘듭니다.**

그래서 공개 API로 부터 한번 응답은 받은 경우 **결과를 Redis에 저장 후 24시간 동안**은 공개 API에 요청 없이 **Redis에서 데이터를 꺼내어** 클라이언트에게 전달하겠습니다. 또한 캐시를 하기 전 속도와 캐시 후 속도 또한 함께 비교해보겠습니다.
