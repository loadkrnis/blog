# 의존관계

객체지향 프로그래밍에서 한 객체가 다른 객체를 사용한다는 것은, 다른 객체를 생성하거나 다른 객체의 메소드를 호출하는 행위를 말한다. 이와 같이 한 객체가 다른객체를 생성 또는 메소드를 호출할 때, 그 객체에
의존한다고 표현한다.

```ts
abstract class Weapon {
    public abstract attck(): void;
}

class Sword implements Weapon {
    attck(): void {
        console.log('Sword');
    }
}

class Player {
    private weapon: Weapon;

    availWeapon(): void {
        this.weapon = new Sword();
        this.weapon.attck(); // Sword
    }
}
```

위 예제를 보면 `Player`는 `Weapon`을 생성하여 `attack`이라는 메소드를 호출하고 있으므로 `Weapon`에 **의존**한다고 볼 수 있다. 또한 매개변수로 전달 받는 경우에도 해당 파라미터에 대해
의존한다고 볼 수 있다. 의존성을 가진다는 것은 의존하고 있는 객체의 코드가 변경됐을 때 그 객체를 의존하는(이용하는) 객체도 변결될 가능성이 있다는 것을 의미한다. 이렇게 의존성을 가지게 되면 변화에 유연하지 못한
구조를 가진 프로그램이라고 할 수 있다.

![단방향 의존](./단방향의존.png)
위 그림처럼 C는 B를 의존하고 B는 A를 의존하고 있는 관계를 가정한다면 A클래스의 변경은 B클래스의 영향을 줄 수 있고, B클래스의 영향이 다시 C클래스에 영향으로 이어질 수 있다.

![순환 의존](./순환의존.png)
위 그림은 의존이 순환하는 구조인데 A클래스의 변화가 C클래스에 영향을 줄 수 있고, C클래스의 변화가 다시 A클래스의 영향으로 이어지게 되며 결국 A클래스의 변화에 대한 영향이 자기 자신에게 또 다른 영향을 줄 수
있다. 이러한 순환 의존 관계를 발생하지 않도록 하는 원칙이 하나 있는데 바로 **의존 역전 원칙(Dependency Inversion Principle: DIP)**라고 한다.

결론적으로 이러한 의존 관계를 가지게 되면 상호간에 영향을 줄 수 있다는 것이고, 즉 내가 변경되면 나를 의존하고 있는 코드들에 영향을 주게되는 것이고 새로운 요구사항이 들어왔을 때 하나의 변동사항이 그것을 의존하고
있는 클래스들에 영향을 줄 수 있다.

# 캡슐화

객체지향의 장점은 코드의 변경이 다른 코드에 영향을 주지 않도록 할 수 있고, 원할한 수정을 할 수 있는 구조를 가지는 것이 객체지향 프로그래밍이라 할 수 있다. 객체지향에서는 이러한 기능 구현사항을 **캡슐화**를
통해서 한 곳의 변화가 다른 곳에 영향을 주는 것을 최소화한다.

**캡슐화**란? 구현된 기능사항을 객체가 내부적으로 감추는 것이다. 구현 사항을 내부적으로 감춰 외부 객체 입장에서는 내부적인 기능사항이 변동되더라도 이 기능사항에 대해서 어떻게 구현되어 있는지 모르기 때문에
내부적으로 수정에 유연함을 가질 수 있다고 한다.

다음 예제 코드는 회원의 만료 날짜에 따라 서비스를 제한하는 기능의 코드입니다. 절자지향적인 방식, 객체지향적인 방식으로 두 가지를 비교해 보겠습니다.





